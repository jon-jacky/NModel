<div class="wikidoc">A <b>Model Program</b> is an executable specification for another program or system, called the <i>implementation</i>.  Usually the model program is much smaller and simpler than the implementation.  The model program can be analyzed to check for design errors in the implementation, can generate test cases for the implementation, and can serve as the <i>oracle</i> that provides the correct results when testing the implementation. <br /><br />In NModel, model programs are used in two ways.  A <i>contract model program</i> represents all of the allowed behaviors (<i>runs</i> or <i>traces</i>) of the implementation, while a <i>scenario model program</i> represents a collection of runs (perhaps just one) that are related in some way: a test suite, or a temporal property to check during analysis.<br /><br />NModel currently supports <i>two</i> languages for writing model programs: C#, and a <i>term representation</i> for <i>Finite State Machines</i> (FSMs). Contract model programs are usually written in C#, while scenario model programs are usually expressed as FSMs.<br /><br />A C# model program uses attributes and data types from the <a href="https://nmodel.codeplex.com/wikipage?title=NModel%20Library&referringTitle=Model%20Programs">NModel library</a>.  It uses the <span class="codeInline">NModel</span> namespaces and references <span class="codeInline">NModel.dll</span>.  It must use the library data types for collections and objects, not the usual C# and .NET data types.<br /><br />A C# model program is defined by the contents of a single namespace, whose name is the model program name. The <i>state</i> (stored information) of a model program is stored in <i>state variables</i>, the static fields and instance fields declared in its namespace.  The <i>actions</i> (state transitions) of the model program are the static methods and instance methods in its namespace that are labeled with the <span class="codeInline">[Action]</span> attribute.  The control structures of a model program are its <i>enabling conditions</i>, Boolean methods that are true in states where an action can occur.   A C# model program  can also have a <i>factory method</i> that prepares the model program for use by the NModel tools (in recent NModel releases, a factory method is not necessary).<br /><br />A C# model program can be built up from separate <i>features</i>, classes identified by the <span class="codeInline">[Feature]</span> attribute, which can be optionally included or excluded from the model program.  <br /><br />Separate model programs can be combined by <a href="https://nmodel.codeplex.com/wikipage?title=Composition&referringTitle=Model%20Programs">composition</a>.  When programs are composed, shared actions synchronize and unshared actions interleave.  Compose a contract model program with a scenario to achieve <i>scenario control</i> for testing, or to check a temporal property during analysis.   Compose two or more contract model programs to build up complex models in a well-structured way.<br /><br />Here is a C# model program named <span class="codeInline">PowerSwitch</span> with one state variable <span class="codeInline">power</span> that can take on the two values <span class="codeInline">On</span> and <span class="codeInline">Off</span>, two actions <span class="codeInline">PowerOn</span> and <span class="codeInline">PowerOff</span>, their enabling conditions <span class="codeInline">PowerOnEnabled</span> and <span class="codeInline">PowerOffEnabled</span>, and a factory method <span class="codeInline">Create</span>.<br /><br /><pre>
using NModel;
using NModel.Attributes;
using NModel.Execution;

namespace PowerSwitch
{
  enum Power { On, Off };
  public static class Contract
  {
    static Power power = Power.Off;

    [Action]
    static void PowerOn() { power = Power.On; }
    static bool PowerOnEnabled() { return power == Power.Off; }

    [Action]
    static void PowerOff() { power = Power.Off; }
    static bool PowerOffEnabled() { return power == Power.On; }

    public static ModelProgram Create() { return LibraryModelProgram.Create(typeof(Contract)); }
  }
}
</pre><br />It is more usual to express such a simple model program as an FSM, represented by a data structure called a <i>term</i>.  Here the first argument of the term is the initial state, the next argument is a list of <i>accepting states</i> where runs are allowed to stop (empty here to indicate runs may stop in any state), and then a list of state transitions.  Each state transition is a triple: the current state, the action (transition label), and the next state.<br /><br /><pre>
FSM(Off, AcceptingStates(), 
    Transitions(t(Off, PowerOn(), On),  t(On, PowerOff(), Off)))
</pre><br />Both the C# model program and the FSM here exhibit the same behavior: they describe the same runs.   In these examples, only one action is enabled in each state.  Model programs can exhibit <i>nondeterminism</i>, where more than one action is enabled in some states.  <br /><br />More complex model programs appear in the <a href="https://nmodel.codeplex.com/wikipage?title=NModel%20Examples&referringTitle=Model%20Programs">examples</a>.<br /><br />The NModel framework provides several command-line programs.  To analyze a model program and visualize its behavior, use <a href="https://nmodel.codeplex.com/wikipage?title=Model%20Program%20Viewer&referringTitle=Model%20Programs">mpv</a>.  To generate test cases, use <a href="https://nmodel.codeplex.com/wikipage?title=Offline%20Test%20Generator&referringTitle=Model%20Programs">otg</a>.  To execute test cases, or to generate and execute test cases on-the-fly, use <a href="https://nmodel.codeplex.com/wikipage?title=Conformance%20Tester&referringTitle=Model%20Programs">ct</a>. <br /></div><div class="ClearBoth"></div>